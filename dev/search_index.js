var documenterSearchIndex = {"docs":
[{"location":"snapshots/#Custom-Snapshots","page":"Custom Snapshots","title":"Custom Snapshots","text":"","category":"section"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"Most simulated experiments take a long time to run, and may be cancelled part way. It is important to be able to save progress on these long-running simulations. For this example, we will take the idea of simulating a Monte-Carlo process. Imagine that your process looks like the below function: ","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Random\nfunction run_simulation(config::Dict{Symbol, Any}, trial_id)\n    epochs = config[:epochs]\n    T = Float64\n    positions = zeros(T, epochs)\n    x = zero(T)\n    for t in 2:epochs\n        x += randn(T)\n        positions[t] = x\n    end\n\n    results = Dict{Symbol, Any}(\n        mean_position => sum(positions) / length(positions)\n    )\n    return results\nend","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"If we want to be able to replicate this process, we should take in a seed for the random values and save a snapshot every so often:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Random\nusing Experimenter\nfunction run_simulation(config::Dict{Symbol, Any}, trial_id)\n    epochs = config[:epochs]\n    seed = config[:seed]\n    snapshot_interval = config[:snapshot_interval]\n    snapshot_label = config[:snapshot_label]\n\n    rng = Random.Xoshiro(seed)\n    T = Float64\n    positions = zeros(T, epochs)\n    x = zero(T)\n    for t in 2:epochs\n        x += randn(rng, T)\n        positions[t] = x\n        if t % snapshot_interval == 0\n            state = Dict{Symbol, Any}(\n                :rng_state => copy(rng),\n                :positions => positions[begin:t]\n            )\n            # Global will only work when executing globally with @execute!\n            save_snapshot_in_global_database(trial_id, state, snapshot_label)\n        end\n    end\n\n    results = Dict{Symbol, Any}(\n        :mean_position => sum(positions) / length(positions)\n    )\n    return results\nend","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"This will save a snapshot associated with the trial_id supplied, whose key is based on the current time. So far, we have only saved the snapshot, but we should implement a method which initialises our simulation, loading from snapshot:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Logging\nfunction init_sim(config::Dict{Symbol,Any}, trial_id)\n    snapshot = get_latest_snapshot_from_global_database(trial_id)\n\n    rng = Random.Xoshiro(config[:seed])\n    T = Float64\n    positions = zeros(T, config[:epochs])\n    x = zero(T)\n    start_t = 2\n    if !isnothing(snapshot)\n        state = snapshot.state # Dict we saved earlier\n        copy!(rng, state[:rng_state]) # Reset RNG\n        saved_positions = state[:positions]\n        # Load existing positions\n        positions[begin:length(saved_positions)] .= saved_positions\n        x = last(saved_positions)\n        start_t = length(saved_positions) + 1\n        @info \"Restored trial $trial_id from snapshot - $(length(saved_positions)) epochs restored.\"\n    end\n\n    return x, positions, start_t, rng, T\nend","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"Finally, we put it altogether:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"# saved in `run.jl`\nusing Random\nusing Experimenter\nfunction run_simulation(config::Dict{Symbol, Any}, trial_id)\n    epochs = config[:epochs]\n    snapshot_interval = config[:snapshot_interval]\n    snapshot_label = config[:snapshot_label]\n\n    x, positions, start_t, rng, T = init_sim(config, trial_id)\n\n    for t in start_t:epochs\n        x += randn(rng, T)\n        positions[t] = x\n\n        if t % snapshot_interval == 0\n            state = Dict{Symbol, Any}(\n                :rng_state => copy(rng),\n                :positions => positions[begin:t]\n            )\n            # Global will only work when executing globally with @execute!\n            save_snapshot_in_global_database(trial_id, state, snapshot_label)\n        end\n    end\n\n    results = Dict{Symbol, Any}(\n        :mean_position => sum(positions) / length(positions)\n    )\n    return results\nend\n# ... include definiton for init_sim function.","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"Now we can create a script to execute this project:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Experimenter\n\nconfig = Dict{Symbol, Any}(\n    :seed => IterableVariable([1234,4567,8910]),\n    :epochs => IterableVariable([500_000, 1_000_000]),\n    :snapshot_interval => 100_000,\n    :snapshot_label => \"MC Snapshots\"\n)\nexperiment = Experiment(\n    name=\"Snapshot Experiment\",\n    include_file=\"run.jl\",\n    function_name=\"run_simulation\",\n    configuration=deepcopy(config)\n)\ndb = open_db(\"experiments.db\")\n@execute experiment db SerialMode true","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"You can use Ctrl+C to cancel the execution before it is complete, and run again to see if the logger has been triggered (i.e. a snapshot has been loaded). If the program runs too quickly, try adding a sleep(0.1) whenever a snapshot is saved, so you get a chance to cancel it to see if it works.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Experimenter.jl is a package that is designed to help you keep track of your experiments and their results. It is built to work with Distributed.jl for parallel writing of results to a SQLite database file.","category":"page"},{"location":"getting_started/#Opening-the-database","page":"Getting Started","title":"Opening the database","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started, first import the library with:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Experimenter","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"After this one needs to create a database to store the results:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"db = open_db(\"experiments.db\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"One can always supply a given directory for the database as well, for example:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"db = open_db(\"experiments.db\", joinpath(pwd(), \"results\"))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The first call to open_db will check if a file already exists. If the file does not exist, Experimenter.jl will create the file and the schema for the database.","category":"page"},{"location":"getting_started/#Defining-the-work-we-want-to-process","page":"Getting Started","title":"Defining the work we want to process","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To run an experiment we need to first define a function which runs our experiment:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# in run.jl\nusing Random\nfunction run_trial(config::Dict{Symbol,Any}, trial_id)\n    results = Dict{Symbol, Any}()\n    sigma = config[:sigma]\n    N = config[:N]\n    seed = config[:seed]\n    rng = Random.Xoshiro(seed)\n    # Perform some calculation\n    results[:distance] = sum(rand(rng) * sigma for _ in 1:N)\n    # Must return a Dict{Symbol, Any}, with the data we want to save\n    return results\nend","category":"page"},{"location":"getting_started/#Creating-an-experiment","page":"Getting Started","title":"Creating an experiment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now we can define a configuration for our experiment:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# in a script\nconfig = Dict{Symbol,Any}(\n    :N => IterableVariable([10, 20]),\n    :seed => IterableVariable([1234, 4321]),\n    :sigma => 1.0\n)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is just a dictionary, with some special wrappers IterableVariable for some of the config values. When we create our experiment, we pass in this configuration and the path to the file with the function to run our experiment:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"experiment = Experiment(\n    name=\"Test Experiment\",\n    include_file=\"run.jl\",\n    function_name=\"run_trial\",\n    configuration=deepcopy(config)\n)","category":"page"},{"location":"getting_started/#Examining-the-trials-of-an-experiment","page":"Getting Started","title":"Examining the trials of an experiment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can look at the set of trials this experiment will create:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"for trial in experiment\n    println(trial.configuration)\nend\n# Dict{Symbol, Any}(:N => 10, :sigma => 1.0, :seed => 1234)\n# Dict{Symbol, Any}(:N => 20, :sigma => 1.0, :seed => 1234)\n# Dict{Symbol, Any}(:N => 10, :sigma => 1.0, :seed => 4321)\n# Dict{Symbol, Any}(:N => 20, :sigma => 1.0, :seed => 4321)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"or, alternatively:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"trials = collect(experiment)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"There are multiple trials in this experiment as we used an IterableVariable wrapper, which says that we want to run a grid search over these specific variables.","category":"page"},{"location":"getting_started/#Executing-an-experiment","page":"Getting Started","title":"Executing an experiment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To execute our experiment, we use the @execute macro. To execute the experiment serially:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@execute experiment db SerialMode","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Instead of SerialMode, we can use ThreadedMode to execute via Threads.@threads, or use DistributedMode to execute via a pmap and run across different workers.","category":"page"},{"location":"getting_started/#Getting-the-results","page":"Getting Started","title":"Getting the results","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once the experiments are completed, we can run:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"trials = get_trials_by_name(db, \"Test Experiment\");","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This will return a Vector{Trial}, where Trial has a results field which is the dictionary we returned from the run_trial function. To get the results we write:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"results = [t.results for t in trials]","category":"page"},{"location":"getting_started/#Re-running-failed-trials","page":"Getting Started","title":"Re-running failed trials","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If a trial did not finish, then the results field will be missing. Whenever we run the @execute macro, it will skip any trial that already has results, and only run the next trials. Therefore ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@execute experiment db SerialMode","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"will not run any more trials, as they have already been completed. However, if the execution stopped (for example killed by the SLURM scheduler due to wall time), then it will only run the trials that have not been completed.","category":"page"},{"location":"getting_started/#Saving-part-way","page":"Getting Started","title":"Saving part way","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If your trials take a long time to finish and may be cancelled during their run, you can always implement a way to save a Snapshot, which allows you to save data you need to restore a trial part way through running. The API for this has not yet been documented, but examples can be seen in the unit tests.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Experimenter","category":"page"},{"location":"#Experimenter","page":"Home","title":"Experimenter","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Experimenter. Head over to Getting Started to get an overview of this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Experimenter]","category":"page"},{"location":"#Experimenter.Experiment","page":"Home","title":"Experimenter.Experiment","text":"Experiment\n\nA database object for storing the configuration options of an experiment.\n\nThe signature of the function supplied should be:\n\nfn(configuration::Dict{Symbol, Any}, trial_id::UUID)\n\nThe function should be available when including the file provided.\n\nA name is required to uniquely label this experiment.\n\n\n\n\n\n","category":"type"},{"location":"#Experimenter.count_values-Tuple{Any}","page":"Home","title":"Experimenter.count_values","text":"count_values(entry)\n\nCounts the number of different values which 'variable' can take.\n\n\n\n\n\n","category":"method"},{"location":"#Experimenter.extract_value-Tuple{Any, Any}","page":"Home","title":"Experimenter.extract_value","text":"extract_value(variable, i)\n\nReturns the i^th possible value of 'variable'.  'i' follows 1 based indexing.\n\n\n\n\n\n","category":"method"},{"location":"#Experimenter.merge_databases!-Tuple{Experimenter.ExperimentDatabase, Experimenter.ExperimentDatabase}","page":"Home","title":"Experimenter.merge_databases!","text":"merge_databases!(primary_db, secondary_db)\n\nSearches all of the records from the secondary database and adds them to the first database.\n\n\n\n\n\n","category":"method"}]
}
