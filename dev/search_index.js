var documenterSearchIndex = {"docs":
[{"location":"store/#Store","page":"Data Store","title":"Store","text":"","category":"section"},{"location":"store/","page":"Data Store","title":"Data Store","text":"As many experiments may require a data of data to be preloaded for each trial, Experiment.jl provides a data store that can be initialised once on each worker to reduce the amount of time required for loading the same data.","category":"page"},{"location":"store/","page":"Data Store","title":"Data Store","text":"This store is intended as a read-only store that is reused upon execution of each of the trials. ","category":"page"},{"location":"store/#Usage","page":"Data Store","title":"Usage","text":"","category":"section"},{"location":"store/","page":"Data Store","title":"Data Store","text":"To start, you must create a function which creates the data to be stored, similar to the functions that runs the trial. As en example:","category":"page"},{"location":"store/","page":"Data Store","title":"Data Store","text":"# Goes inside the same file as your experiment run file (i.e. the file that get's included).\nfunction create_global_store(config)\n    # config is the global configuration given to the experiment\n    data = Dict{Symbol, Any}(\n        :dataset => rand(1000),\n        :flag => false,\n        # etc...\n    )\n    return data\nend","category":"page"},{"location":"store/","page":"Data Store","title":"Data Store","text":"The variable config will be the configuration provided to the Experiment struct created for your experiment. Importantly, this function will return a Dict{Symbol, Any}.","category":"page"},{"location":"store/","page":"Data Store","title":"Data Store","text":"The name of this function can be anything, but you need to supply it to the experiment when it is being created, i.e.","category":"page"},{"location":"store/","page":"Data Store","title":"Data Store","text":"experiment = Experiment(\n    name=\"Test Experiment\",\n    include_file=\"run.jl\",\n    function_name=\"run_trial\",\n    init_store_function_name=\"create_global_store\",\n    configuration=config\n)","category":"page"},{"location":"store/","page":"Data Store","title":"Data Store","text":"Inside your run_trial function, you can access the global store using get_global_store","category":"page"},{"location":"store/","page":"Data Store","title":"Data Store","text":"using Experimenter # exports get_global_store\nfunction run_trial(config, trial_id)\n    store = get_global_store()\n    dataset = store[:dataset]\n    # gather your results\n    return results\nend","category":"page"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/#Database-Management","page":"Public API","title":"Database Management","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"open_db\nexport_db\nrestore_from_db\nmerge_databases!","category":"page"},{"location":"api/#Experimenter.open_db","page":"Public API","title":"Experimenter.open_db","text":"open_db(database_name, [experiment_folder, create_folder]; in_memory=false)\n\nOpens a database and prepares it with the Experimenter.jl schema with tables for Experiment, Trial and Snapshot. If the database already exists, it will open it and not overwrite the existing data.\n\nSetting in_memory to true will skip all of the arguments and create the database \"in memory\" and hence, will not persist.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.export_db","page":"Public API","title":"Experimenter.export_db","text":"export_db(db::ExperimentDatabase, outfile::AbstractString, experiment_names...)\n\nOpens a new database at outfile and inserts experiments from db into the new db, where the names of the experiment are listed in the final input.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.restore_from_db","page":"Public API","title":"Experimenter.restore_from_db","text":"restore_from_db(db::ExperimentDatabase, experiment::Experiment)\n\nSearches the db for the supplied experiment, matching on the configuration and the name, disregarding the unique ID.\n\nIf experiment already exists in the db, returns that experiment with the db's UUID for it, otherwise return the input experiment.\n\nWill error if the experiment exists but does not match the input experiment configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.merge_databases!","page":"Public API","title":"Experimenter.merge_databases!","text":"merge_databases!(primary_db, secondary_db)\n\nSearches all of the records from the secondary database and adds them to the first database.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experiments","page":"Public API","title":"Experiments","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Experiment\nget_experiment\nget_experiments\nget_experiment_by_name\nget_ratio_completed_trials_by_name","category":"page"},{"location":"api/#Experimenter.Experiment","page":"Public API","title":"Experimenter.Experiment","text":"Experiment\n\nA database object for storing the configuration options of an experiment.\n\nThe signature of the function supplied should be:\n\nfn(configuration::Dict{Symbol, Any}, trial_id::UUID)\n\nThe function should be available when including the file provided.\n\nA name is required to uniquely label this experiment.\n\n\n\n\n\n","category":"type"},{"location":"api/#Experimenter.get_experiment","page":"Public API","title":"Experimenter.get_experiment","text":"get_experiment(db::ExperimentDatabase, experiment_id)\n\nSearches the db for the given experiment_id which can be given as a string or UUID.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.get_experiments","page":"Public API","title":"Experimenter.get_experiments","text":"get_experiments(db::ExperimentDatabase)\n\nReturns a vector of all experiments in the database.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.get_experiment_by_name","page":"Public API","title":"Experimenter.get_experiment_by_name","text":"get_experiment(db::ExperimentDatabase, name)\n\nSearches the db for an experiment with the experiment name set to name. Returns that experiment.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.get_ratio_completed_trials_by_name","page":"Public API","title":"Experimenter.get_ratio_completed_trials_by_name","text":"get_ratio_completed_trials_by_name(db::ExperimentDatabase, name)\n\nCalculates the ratio of completed trials for the given experiment with name name, without fetching the results.\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-Storage","page":"Public API","title":"Data Storage","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"get_global_store","category":"page"},{"location":"api/#Experimenter.get_global_store","page":"Public API","title":"Experimenter.get_global_store","text":"get_global_store()\n\nTries to get the global store that is initialised by the supplied function with the name specified by init_store_function_name set in  the running experiment. This store is local to each worker.\n\nSetup\n\nTo create the store, add a function in your include file which returns a dictionary of type Dict{Symbol, Any}, which has the signature similar to:\n\nfunction create_global_store(config)\n    # config is the global configuration given to the experiment\n    data = Dict{Symbol, Any}(\n        :dataset => rand(1000),\n        :flag => false,\n        # etc...\n    )\n    return data\nend\n\nInside your main experiment execution function, you can get this store via get_global_store, which is exported by Experimenter.\n\nfunction myrunner(config, trial_id)\n    store = get_global_store()\n    dataset = store[:dataset] # Retrieve the keys from the store\n    # process data\n    return results\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#Trials","page":"Public API","title":"Trials","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"get_trial\nget_trials\nget_trials_by_name\nget_trials_ids_by_name","category":"page"},{"location":"api/#Experimenter.get_trial","page":"Public API","title":"Experimenter.get_trial","text":"get_trial(db::ExperimentDatabase, trial_id)\n\nGets the trial with the matching trial_id (string or UUID) from the database.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.get_trials","page":"Public API","title":"Experimenter.get_trials","text":"get_trial(db::ExperimentDatabase, experiment_id)\n\nGets all trials from the database under the experiment_id supplied.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.get_trials_by_name","page":"Public API","title":"Experimenter.get_trials_by_name","text":"get_trials_by_name(db::ExperimentDatabase, name)\n\nGets all trials from the database for the experiment with the name name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.get_trials_ids_by_name","page":"Public API","title":"Experimenter.get_trials_ids_by_name","text":"get_trials_ids_by_name(db::ExperimentDatabase, name)\n\nGets just the trial IDs from the database for the experiment with the name name.\n\n\n\n\n\n","category":"function"},{"location":"api/#Execution","page":"Public API","title":"Execution","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"@execute\nSerialMode\nMultithreadedMode\nDistributedMode","category":"page"},{"location":"api/#Experimenter.@execute","page":"Public API","title":"Experimenter.@execute","text":"@execute experiment database [mode=SerialMode use_progress=false directory=pwd()]\n\nRuns the experiment out of global scope, saving results in the database, skipping all already executed trials.\n\nArgs:\n\nmode: Specifies SerialMode, MultithreadedMode or DistributedMode to execute serially or in parallel. use_progress: Shows a progress bar directory: Directory to change the current process (or worker processes) to for execution.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Experimenter.ExecutionModes.SerialMode","page":"Public API","title":"Experimenter.ExecutionModes.SerialMode","text":"Executes the trials of the experiment one of the other, sequentially.\n\n\n\n\n\n","category":"type"},{"location":"api/#Experimenter.ExecutionModes.MultithreadedMode","page":"Public API","title":"Experimenter.ExecutionModes.MultithreadedMode","text":"Executes the trials of the experiment in parallel using Threads.@Threads\n\n\n\n\n\n","category":"type"},{"location":"api/#Experimenter.ExecutionModes.DistributedMode","page":"Public API","title":"Experimenter.ExecutionModes.DistributedMode","text":"Executes the trials of the experiment in parallel using Distributed.jls pmap.\n\n\n\n\n\n","category":"type"},{"location":"api/#Snapshots","page":"Public API","title":"Snapshots","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"get_snapshots\nlatest_snapshot\nsave_snapshot!\nget_latest_snapshot_from_global_database\nsave_snapshot_in_global_database","category":"page"},{"location":"api/#Experimenter.get_snapshots","page":"Public API","title":"Experimenter.get_snapshots","text":"get_snapshots(db::ExperimentDatabase, trial_id)\n\nGets all the associated snapshots (as a vector) from the database for a given trial with matching trial_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.latest_snapshot","page":"Public API","title":"Experimenter.latest_snapshot","text":"latest_snapshot(db::ExperimentDatabase, trial_id)\n\nGets the latest snapshot from the database for a given trial with matching trial_id, using the date of the most recent snapshot.\n\nKnown to have issues when snapshots are created within the same second.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.save_snapshot!","page":"Public API","title":"Experimenter.save_snapshot!","text":"save_snapshot!(db::ExperimentDatabase, trial_id::UUID, state::Dict{Symbol,Any}, [label])\n\nSaves the snapshot with given state in the database, associating with the trial with matching trial_id. Automatically saves the time of the snapshot.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.get_latest_snapshot_from_global_database","page":"Public API","title":"Experimenter.get_latest_snapshot_from_global_database","text":"get_latest_snapshot_from_global_database(trial_id::UUID)\n\nSame as get_latest_snapshot, but in the given global database. Redirects to the master worker if on a distributed node. Only works when using @execute.\n\n\n\n\n\n","category":"function"},{"location":"api/#Experimenter.save_snapshot_in_global_database","page":"Public API","title":"Experimenter.save_snapshot_in_global_database","text":"save_snapshot_in_global_database(trial_id::UUID, state, [label])\n\nSave the results of a specific trial from the global database, with the supplied state and optional label. Redirects to the master node if on a worker node. Locks to secure access.\n\n\n\n\n\n","category":"function"},{"location":"api/#Misc","page":"Public API","title":"Misc","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"LinearVariable\nLogLinearVariable\nRepeatVariable\nIterableVariable\nMatchIterableVariable","category":"page"},{"location":"api/#Experimenter.LinearVariable","page":"Public API","title":"Experimenter.LinearVariable","text":"LinearVariable(min, max, n)\n\nSpecifies a range for a parameter variable to take, from min to max inclusive with n total values.\n\n\n\n\n\n","category":"type"},{"location":"api/#Experimenter.LogLinearVariable","page":"Public API","title":"Experimenter.LogLinearVariable","text":"LogLinearVariable(min, max, n)\n\nA linearly spaced parameter variable in log space. If min=1 and max=100 and n=3 then the values are [1,10,100].\n\n\n\n\n\n","category":"type"},{"location":"api/#Experimenter.RepeatVariable","page":"Public API","title":"Experimenter.RepeatVariable","text":"RepeatVariable(val, n)\n\nSpecifies a parameter variable that outputs the same value val n times. \n\n\n\n\n\n","category":"type"},{"location":"api/#Experimenter.IterableVariable","page":"Public API","title":"Experimenter.IterableVariable","text":"IterableVariable(iter)\n\nWraps a given iterator iter to tell the experiment to perform a grid search over each element of the iterator for the given parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/#Experimenter.MatchIterableVariable","page":"Public API","title":"Experimenter.MatchIterableVariable","text":"MatchIterableVariable(iter)\n\nThis type of variable matches with the product from the other AbstractVariables in the configuration.\n\nThis does not form part of the product variables (grid search), but instead uniques matches with that product.\n\n\n\n\n\n","category":"type"},{"location":"snapshots/#Custom-Snapshots","page":"Custom Snapshots","title":"Custom Snapshots","text":"","category":"section"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"Most simulated experiments take a long time to run, and may be cancelled part way. It is important to be able to save progress on these long-running simulations. For this example, we will take the idea of simulating a Monte-Carlo process. Imagine that your process looks like the below function: ","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Random\nfunction run_simulation(config::Dict{Symbol, Any}, trial_id)\n    epochs = config[:epochs]\n    T = Float64\n    positions = zeros(T, epochs)\n    x = zero(T)\n    for t in 2:epochs\n        x += randn(T)\n        positions[t] = x\n    end\n\n    results = Dict{Symbol, Any}(\n        mean_position => sum(positions) / length(positions)\n    )\n    return results\nend","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"If we want to be able to replicate this process, we should take in a seed for the random values and save a snapshot every so often:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Random\nusing Experimenter\nfunction run_simulation(config::Dict{Symbol, Any}, trial_id)\n    epochs = config[:epochs]\n    seed = config[:seed]\n    snapshot_interval = config[:snapshot_interval]\n    snapshot_label = config[:snapshot_label]\n\n    rng = Random.Xoshiro(seed)\n    T = Float64\n    positions = zeros(T, epochs)\n    x = zero(T)\n    for t in 2:epochs\n        x += randn(rng, T)\n        positions[t] = x\n        if t % snapshot_interval == 0\n            state = Dict{Symbol, Any}(\n                :rng_state => copy(rng),\n                :positions => positions[begin:t]\n            )\n            # Global will only work when executing globally with @execute!\n            save_snapshot_in_global_database(trial_id, state, snapshot_label)\n        end\n    end\n\n    results = Dict{Symbol, Any}(\n        :mean_position => sum(positions) / length(positions)\n    )\n    return results\nend","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"This will save a snapshot associated with the trial_id supplied, whose key is based on the current time. So far, we have only saved the snapshot, but we should implement a method which initialises our simulation, loading from snapshot:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Logging\nfunction init_sim(config::Dict{Symbol,Any}, trial_id)\n    snapshot = get_latest_snapshot_from_global_database(trial_id)\n\n    rng = Random.Xoshiro(config[:seed])\n    T = Float64\n    positions = zeros(T, config[:epochs])\n    x = zero(T)\n    start_t = 2\n    if !isnothing(snapshot)\n        state = snapshot.state # Dict we saved earlier\n        copy!(rng, state[:rng_state]) # Reset RNG\n        saved_positions = state[:positions]\n        # Load existing positions\n        positions[begin:length(saved_positions)] .= saved_positions\n        x = last(saved_positions)\n        start_t = length(saved_positions) + 1\n        @info \"Restored trial $trial_id from snapshot - $(length(saved_positions)) epochs restored.\"\n    end\n\n    return x, positions, start_t, rng, T\nend","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"Finally, we put it altogether:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"# saved in `run.jl`\nusing Random\nusing Experimenter\nfunction run_simulation(config::Dict{Symbol, Any}, trial_id)\n    epochs = config[:epochs]\n    snapshot_interval = config[:snapshot_interval]\n    snapshot_label = config[:snapshot_label]\n\n    x, positions, start_t, rng, T = init_sim(config, trial_id)\n\n    for t in start_t:epochs\n        x += randn(rng, T)\n        positions[t] = x\n\n        if t % snapshot_interval == 0\n            state = Dict{Symbol, Any}(\n                :rng_state => copy(rng),\n                :positions => positions[begin:t]\n            )\n            # Global will only work when executing globally with @execute!\n            save_snapshot_in_global_database(trial_id, state, snapshot_label)\n        end\n    end\n\n    results = Dict{Symbol, Any}(\n        :mean_position => sum(positions) / length(positions)\n    )\n    return results\nend\n# ... include definiton for init_sim function.","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"Now we can create a script to execute this project:","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"using Experimenter\n\nconfig = Dict{Symbol, Any}(\n    :seed => IterableVariable([1234,4567,8910]),\n    :epochs => IterableVariable([500_000, 1_000_000]),\n    :snapshot_interval => 100_000,\n    :snapshot_label => \"MC Snapshots\"\n)\nexperiment = Experiment(\n    name=\"Snapshot Experiment\",\n    include_file=\"run.jl\",\n    function_name=\"run_simulation\",\n    configuration=deepcopy(config)\n)\ndb = open_db(\"experiments.db\")\n@execute experiment db SerialMode true","category":"page"},{"location":"snapshots/","page":"Custom Snapshots","title":"Custom Snapshots","text":"You can use Ctrl+C to cancel the execution before it is complete, and run again to see if the logger has been triggered (i.e. a snapshot has been loaded). If the program runs too quickly, try adding a sleep(0.1) whenever a snapshot is saved, so you get a chance to cancel it to see if it works.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Experimenter.jl is a package that is designed to help you keep track of your experiments and their results. It is built to work with Distributed.jl for parallel writing of results to a SQLite database file.","category":"page"},{"location":"getting_started/#Opening-the-database","page":"Getting Started","title":"Opening the database","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To get started, first import the library with:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Experimenter","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"After this one needs to create a database to store the results:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"db = open_db(\"experiments.db\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"One can always supply a given directory for the database as well, for example:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"db = open_db(\"experiments.db\", joinpath(pwd(), \"results\"))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The first call to open_db will check if a file already exists. If the file does not exist, Experimenter.jl will create the file and the schema for the database.","category":"page"},{"location":"getting_started/#Defining-the-work-we-want-to-process","page":"Getting Started","title":"Defining the work we want to process","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To run an experiment we need to first define a function which runs our experiment:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# in run.jl\nusing Random\nfunction run_trial(config::Dict{Symbol,Any}, trial_id)\n    results = Dict{Symbol, Any}()\n    sigma = config[:sigma]\n    N = config[:N]\n    seed = config[:seed]\n    rng = Random.Xoshiro(seed)\n    # Perform some calculation\n    results[:distance] = sum(rand(rng) * sigma for _ in 1:N)\n    # Must return a Dict{Symbol, Any}, with the data we want to save\n    return results\nend","category":"page"},{"location":"getting_started/#Creating-an-experiment","page":"Getting Started","title":"Creating an experiment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now we can define a configuration for our experiment:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# in a script\nconfig = Dict{Symbol,Any}(\n    :N => IterableVariable([10, 20]),\n    :seed => IterableVariable([1234, 4321]),\n    :sigma => 1.0\n)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is just a dictionary, with some special wrappers IterableVariable for some of the config values. When we create our experiment, we pass in this configuration and the path to the file with the function to run our experiment:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"experiment = Experiment(\n    name=\"Test Experiment\",\n    include_file=\"run.jl\",\n    function_name=\"run_trial\",\n    configuration=deepcopy(config)\n)","category":"page"},{"location":"getting_started/#Examining-the-trials-of-an-experiment","page":"Getting Started","title":"Examining the trials of an experiment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can look at the set of trials this experiment will create:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"for trial in experiment\n    println(trial.configuration)\nend\n# Dict{Symbol, Any}(:N => 10, :sigma => 1.0, :seed => 1234)\n# Dict{Symbol, Any}(:N => 20, :sigma => 1.0, :seed => 1234)\n# Dict{Symbol, Any}(:N => 10, :sigma => 1.0, :seed => 4321)\n# Dict{Symbol, Any}(:N => 20, :sigma => 1.0, :seed => 4321)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"or, alternatively:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"trials = collect(experiment)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"There are multiple trials in this experiment as we used an IterableVariable wrapper, which says that we want to run a grid search over these specific variables.","category":"page"},{"location":"getting_started/#Executing-an-experiment","page":"Getting Started","title":"Executing an experiment","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To execute our experiment, we use the @execute macro. To execute the experiment serially:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@execute experiment db SerialMode","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Instead of SerialMode, we can use ThreadedMode to execute via Threads.@threads, or use DistributedMode to execute via a pmap and run across different workers.","category":"page"},{"location":"getting_started/#Getting-the-results","page":"Getting Started","title":"Getting the results","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Once the experiments are completed, we can run:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"trials = get_trials_by_name(db, \"Test Experiment\");","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This will return a Vector{Trial}, where Trial has a results field which is the dictionary we returned from the run_trial function. To get the results we write:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"results = [t.results for t in trials]","category":"page"},{"location":"getting_started/#Re-running-failed-trials","page":"Getting Started","title":"Re-running failed trials","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If a trial did not finish, then the results field will be missing. Whenever we run the @execute macro, it will skip any trial that already has results, and only run the next trials. Therefore ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@execute experiment db SerialMode","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"will not run any more trials, as they have already been completed. However, if the execution stopped (for example killed by the SLURM scheduler due to wall time), then it will only run the trials that have not been completed.","category":"page"},{"location":"getting_started/#Saving-part-way","page":"Getting Started","title":"Saving part way","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If your trials take a long time to finish and may be cancelled during their run, you can always implement a way to save a Snapshot, which allows you to save data you need to restore a trial part way through running. The API for this has not yet been documented, but examples can be seen in the unit tests.","category":"page"},{"location":"getting_started/#What-is-an-Experiment?","page":"Getting Started","title":"What is an Experiment?","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"An experiment sets up a configuration that specifies (by default) a grid search over variables. If none of the special classes such as IterableVariable, LinearVariable, LogLinearVariable etc are used as values in the configuration dictionary, this will specify only a single trial. However, if these special types are used, an experiment will have multiple trials, whose configurations are created via a grid search over the special AbstractVariables provided, with each of these values being replaced by a single element in these iterables.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As an example the following configuration:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"config = Dict{Symbol, Any}(\n    :a => IterableVariable([\"a\", \"b\"]),\n    :b => LinearVariable(1, 4, 5),\n    :c => \"constant value\"\n)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Since the first two parts are marked with a type of AbstractVariable (or concrete type of), these will form our grid search. The actual configurations will look like the following code:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"for a in [\"a\", \"b\"]\n    for b in LinRange(1, 4, 5)\n        trial_config = Dict{Symbol, Any}(\n            :a => a,\n            :b => b,\n            :c => \"constant value\"\n        )\n    end\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A matched variable will not form part of the grid, but works as follows:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"matched = rand(2*5)\ni = 1\nfor a in [\"a\", \"b\"]\n    for b in LinRange(1, 4, 5)\n        trial_config = Dict{Symbol, Any}(\n            :a => a,\n            :b => b,\n            :c => \"constant value\",\n            :matched => matched[i]\n        )\n        i += 1\n    end\nend","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The matched variable must have as many entries as there are in the grid search.","category":"page"},{"location":"execution/#Running-your-Experiments","page":"Running your Experiments","title":"Running your Experiments","text":"","category":"section"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"Once you have created an experiment you can run it with the @execute macro supplied by Experimenter.jl, suppose you already have an experiment stored in the experiment variable and a database opened with the variable db, then you can execute simply with:","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"@execute experiment db SerialMode","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"Which will only execute trials from the experiment that have not been completed. It is up to you to implement how to continue your simulations from snapshots, using the Snapshots API. ","category":"page"},{"location":"execution/#Executing-in-Parallel","page":"Running your Experiments","title":"Executing in Parallel","text":"","category":"section"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"There are two main ways of executing your experiments in parallel: multithreading (Threads) or multiprocessing (Distributed). The former has lower latency, but the latter scales to working on across a cluster. The easiest option if you are executing on a single computer, use:","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"@execute experiment db MultithreadedMode","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"By default, this will use as many threads as you have enabled. You can set this using the environment variable JULIA_NUM_THREADS, or by starting Julia with --threads=X, replacing X with the number you want. You can check what your current setting is with Threads.nthreads().","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"On a cluster, we can change the execution mode to DistributedMode:","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"@execute experiment db DistributedMode","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"This internally uses pmap from the Distributed.jl standard library, parallelising across all open workers. You can check the number of distributed workers with:","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"using Distributed\nnworkers()","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"Experimenter.jl will not spin up processes for you, this is something you have to do yourself, see Distributed Execution for an in depth example. ","category":"page"},{"location":"execution/#Heterogeneous-Execution","page":"Running your Experiments","title":"Heterogeneous Execution","text":"","category":"section"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"If you want each distributed worker to be able to run multiple jobs at the same time, you can select a heterogeneous execution scheduling mode, which will allow each worker to run multiple trials simulatenously using multithreading. An example use case for this is where you have multiple nodes, each with many cores, and you do not wish to pay the memory cost from each separate process. Additionally, you can load data in a single process which can be reused by each execution in the same process. This mode may also allow multiple trials to share resources, such as a GPU, which typically only supports one process.","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"To run this, you simple change the mode to the HeterogeneousMode option, providing the number of threads to use on each worker, e.g.","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"@execute experiment db HeterogeneousMode(2)","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"which will allow each distributed worker to run two trials simulatenously via multithreading. If this option is selected, it is encouraged that you enable multiple threads per worker when launching the process, e.g. with addprocs:","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"addprocs(4; exeflags=[\"--threads=2\"])","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"Otherwise, each worker may only have access to a single thread and the overall performance throughput will be worse.","category":"page"},{"location":"execution/","page":"Running your Experiments","title":"Running your Experiments","text":"<!– TODO: Update the manifest to point to current experimenter version in docs –>","category":"page"},{"location":"distributed/#Distributed-Execution","page":"Distributed Execution","title":"Distributed Execution","text":"","category":"section"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"If you want to execute on a single node, but using multiprocessing (i.e. Distributed.jl), then you can start Julia with","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"julia --project -p 8","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"To start Julia with 8 workers. Alternatively, you can add processes while running:","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"using Distributed\naddprocs(8)","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"As long as nworkers() show more than one worker, then your execution of trials will occur in parallel, across these workers.","category":"page"},{"location":"distributed/#Configuring-SLURM","page":"Distributed Execution","title":"Configuring SLURM","text":"","category":"section"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"SLURM is one of the most popular schedulers on HPC clusters, which we can integrate with Distributed.jl to spawn our workers automatically. See this gist for some scripts to make this process easier.","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"Let's start with spawning your processes:","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"using Distributed\nusing ClusterManagers\nnum_tasks = parse(Int, ENV[\"SLURM_NTASKS\"]) # One process per task\ncpus_per_task = parse(Int, ENV[\"SLURM_CPUS_PER_TASK\"]) # Assign threads per process\naddprocs(SlurmManager(num_tasks,\n exe_flags=[\n    \"--project\",\n    \"--threads=$cpus_per_task\"]\n    )\n)","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"You can check out ClusterManagers.jl for your own cluster software if you are not using SLURM, but the process will be similar to this.","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"Once this has been done, simply include your file which configures and runs your experiment using DistributedMode execution mode as detailed above and save in a file like run_script.jl.","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"For SLURM, you can make a slurm script to submit, for example:","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"#!/bin/bash\n\n#SBATCH --ntasks=8\n#SBATCH --cpus-per-task=4\n#SBATCH --mem-per-cpu=2G\n#SBATCH --time=00:30:00\n\nmodule load julia/1.8.2\n\njulia --project run_script.jl","category":"page"},{"location":"distributed/","page":"Distributed Execution","title":"Distributed Execution","text":"which can be saved to launch_experiment.sh and run with sbatch launch_experiment.sh. Note that you may need to include addition SBATCH directives like --account on your cluster. Check your cluster's documentation for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Experimenter","category":"page"},{"location":"#Experimenter","page":"Home","title":"Experimenter","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for easily running experiments for different parameters and saving the results in a centralised database","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create a local SQLite database to store the results of your experiment.\nProvides a standard structure for executing code across a range of parameters.\nProvides saving of results into the database using standard Julia types.\nProvides an @execute macro that will execute an experiment (consisting of many trails with different parameters). Can execute serially, or in parallel with a choice of multithreading or multiprocessing.\nAutomatically skips completed trials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Head over to Getting Started to get an overview of this package.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"getting_started.md\",\n    \"execution.md\",\n    \"distributed.md\",\n    \"store.md\",\n    \"snapshots.md\"\n]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out the API at Public API.","category":"page"}]
}
